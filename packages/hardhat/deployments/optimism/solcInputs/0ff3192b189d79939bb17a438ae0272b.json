{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/automation/interfaces/AutomationCompatibleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AutomationCompatibleInterface {\n  /**\n   * @notice method that is simulated by the keepers to see if any work actually\n   * needs to be performed. This method does does not actually need to be\n   * executable, and since it is only ever simulated it can consume lots of gas.\n   * @dev To ensure that it is never called, you may want to add the\n   * cannotExecute modifier from KeeperBase to your implementation of this\n   * method.\n   * @param checkData specified in the upkeep registration so it is always the\n   * same for a registered upkeep. This can easily be broken down into specific\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\n   * same contract and easily differentiated by the contract.\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\n   * performUpkeep or not.\n   * @return performData bytes that the keeper should call performUpkeep with, if\n   * upkeep is needed. If you would like to encode data to decode later, try\n   * `abi.encode`.\n   */\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\n\n  /**\n   * @notice method that is actually executed by the keepers, via the registry.\n   * The data returned by the checkUpkeep simulation will be passed into\n   * this method to actually be executed.\n   * @dev The input to this method should not be trusted, and the caller of the\n   * method should not even be restricted to any single registry. Anyone should\n   * be able call it, and the input should be validated, there is no guarantee\n   * that the data passed in is the performData returned from checkUpkeep. This\n   * could happen due to malicious keepers, racing keepers, or simply a state\n   * change while the performUpkeep transaction is waiting for confirmation.\n   * Always validate the data passed in.\n   * @param performData is the data which was passed back from the checkData\n   * simulation. If it is encoded, it can easily be decoded into other types by\n   * calling `abi.decode`. This data should not be trusted, and should be\n   * validated against the contract's current state.\n   */\n  function performUpkeep(bytes calldata performData) external;\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter is IUniswapV3SwapCallback {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"
    },
    "@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.6.0;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nlibrary TransferHelper {\n    /// @notice Transfers tokens from the targeted address to the given destination\n    /// @notice Errors with 'STF' if transfer fails\n    /// @param token The contract address of the token to be transferred\n    /// @param from The originating address from which the tokens will be transferred\n    /// @param to The destination address of the transfer\n    /// @param value The amount to be transferred\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) =\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\n    }\n\n    /// @notice Transfers tokens from msg.sender to a recipient\n    /// @dev Errors with ST if transfer fails\n    /// @param token The contract address of the token which will be transferred\n    /// @param to The recipient of the transfer\n    /// @param value The value of the transfer\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\n    }\n\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\n    /// @dev Errors with 'SA' if transfer fails\n    /// @param token The contract address of the token to be approved\n    /// @param to The target of the approval\n    /// @param value The amount of the given token the target will be allowed to spend\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\n    }\n\n    /// @notice Transfers ETH to the recipient address\n    /// @dev Fails with `STE`\n    /// @param to The destination of the transfer\n    /// @param value The value to be transferred\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'STE');\n    }\n}\n"
    },
    "contracts/ITrailMix.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\ninterface ITrailMix {\n\n\t// Function signatures\n\tfunction deposit(uint256 amount, uint256 tslThreshold) external;\n\n\tfunction withdraw() external;\n\n    function checkUpkeepNeeded() external view returns (bool, bool, uint256);\n\n\tfunction updateTSLThreshold(uint256 newThreshold) external;\n\n\tfunction getLatestPrice() external view returns (uint256);\n\n\tfunction swapOnUniswap(uint256 amount) external;\n\n\tfunction getTwapPrice() external view returns (uint256);\n\n\tfunction getExactPrice() external view returns (uint256);\n\n\tfunction activateSlippageProtection() external;\n\n\tfunction getERC20Balance() external view returns (uint256);\n\n\tfunction getStablecoinBalance() external view returns (uint256);\n\n\tfunction getTSLThreshold() external view returns (uint256);\n\n\tfunction isTSLActive() external view returns (bool);\n\n\tfunction getERC20TokenAddress() external view returns (address);\n\n\tfunction getStablecoinAddress() external view returns (address);\n\n\tfunction getUniswapRouterAddress() external view returns (address);\n\n\tfunction getTrailAmount() external view returns (uint256);\n\n\tfunction getManager() external view returns (address);\n\n    function getCreator() external view returns (address);\n\n\tfunction getGranularity() external view returns (uint256);\n\n\tfunction getUniswapPool() external view returns (address);\n}\n"
    },
    "contracts/IUniswapOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\ninterface IUniswapOracle {\n    function estimateAmountOut(\n        address pool,\n        address tokenIn,\n        uint128 amountIn,\n        uint32 secondsAgo\n    ) external view returns (uint amountOut);\n}\n"
    },
    "contracts/TrailMix.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\npragma abicoder v2;\n\nimport { AutomationCompatibleInterface } from \"@chainlink/contracts/src/v0.8/automation/interfaces/AutomationCompatibleInterface.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\";\nimport { ISwapRouter } from \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\";\n// import {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { IUniswapOracle } from \"./IUniswapOracle.sol\";\n\nerror InvalidAmount(); // Error for when the deposit amount is not positive\nerror TransferFailed(); // Error for when the token transfer fails\n\ncontract TrailMix is ReentrancyGuard {\n\taddress private immutable i_manager; //address of the manager contract\n\taddress private immutable i_creator; // address of the creator of the contract\n\n\taddress private s_erc20Token;\n\taddress private s_stablecoin;\n\n\tISwapRouter private s_uniswapRouter;\n\taddress public immutable s_uniswapPool;\n\tIUniswapOracle private s_uniswapOracle; // TWAP oracle for Uniswap V3\n\n\tuint256 private immutable s_trailAmount; // Amount to trail by as a %\n\tuint256 private s_tslThreshold; // User's TSL threshold\n\tuint256 private s_erc20Balance;\n\tuint256 private s_stablecoinBalance; // User's ERC20 token balance\n\tuint256 private s_granularity; //  % price increase to trigger an update\n\tbool private s_isTSLActive; // Indicates if the TSL is currently active\n\tbool private slippageProtection; // Indicates if slippage protection is enabled\n\tuint24 private s_poolFee; \n\n\t//events are emitted in the manager contract\n\n\tconstructor(\n\t\taddress _manager,\n\t\taddress _creator,\n\t\taddress _erc20Token,\n\t\taddress _stablecoin,\n\t\taddress _uniswapRouter,\n\t\taddress _uniswapPool,\n\t\taddress _uniswapOracle,\n\t\tuint256 _trailAmount,\n\t\tuint256 granularity,\n\t\tuint24 _poolFee\n\t) {\n\t\ti_manager = _manager;\n\t\ti_creator = _creator;\n\n\t\ts_erc20Token = _erc20Token;\n\t\ts_stablecoin = _stablecoin;\n\n\t\ts_uniswapRouter = ISwapRouter(_uniswapRouter);\n\t\ts_uniswapOracle = IUniswapOracle(_uniswapOracle);\n\t\ts_uniswapPool = _uniswapPool;\n\n\t\ts_isTSLActive = false;\n\t\ts_trailAmount = _trailAmount;\n\t\tslippageProtection = true;\n\t\ts_granularity = granularity;\n\t\ts_poolFee = _poolFee;\n\t}\n\n\tmodifier onlyManager() {\n\t\trequire(msg.sender == i_manager, \"only callable by manager contract\");\n\t\t_;\n\t}\n\n\t/**\n\t * @notice Deposits a specified amount of the ERC20 token into the contract.\n\t * @param amount The amount of the ERC20 token to deposit.\n\t * @param tslThreshold The initial trailing stop loss threshold as a percentage.\n\t */\n\tfunction deposit(\n\t\tuint256 amount,\n\t\tuint256 tslThreshold\n\t) external onlyManager {\n\t\tif (amount <= 0) {\n\t\t\trevert InvalidAmount();\n\t\t}\n\n\t\tbool transferSuccess = IERC20(s_erc20Token).transferFrom(\n\t\t\ti_manager,\n\t\t\taddress(this),\n\t\t\tamount\n\t\t);\n\t\tif (!transferSuccess) {\n\t\t\trevert TransferFailed();\n\t\t}\n\n\t\ts_erc20Balance += amount;\n\n\t\tif (!s_isTSLActive) {\n\t\t\t// If TSL is not active, set the threshold and activate TSL\n\t\t\ts_tslThreshold = (tslThreshold * (100 - s_trailAmount)) / 100;\n\t\t\ts_isTSLActive = true;\n\t\t}\n\t}\n\n\t/**\n\t * @notice Withdraws the user's funds from the contract.\n\t * @dev Allows withdrawal of either ERC20 tokens or stablecoins, based on TSL status.\n\t */\n\tfunction withdraw() external onlyManager {\n\t\tuint256 withdrawalAmount;\n\n\t\tif (!s_isTSLActive) {\n\t\t\t// If TSL is not active, assume user wants to withdraw stablecoins\n\t\t\t// Logic to handle stablecoin withdrawal\n\t\t\twithdrawalAmount = s_stablecoinBalance;\n\t\t\tif (withdrawalAmount <= 0) {\n\t\t\t\trevert InvalidAmount();\n\t\t\t}\n\t\t\ts_stablecoinBalance = 0;\n\t\t\tTransferHelper.safeTransfer(\n\t\t\t\ts_stablecoin,\n\t\t\t\ti_creator, // sends funds to the contract creator\n\t\t\t\twithdrawalAmount\n\t\t\t);\n\t\t} else {\n\t\t\t// If TSL is active, user withdraws their ERC20 tokens\n\t\t\twithdrawalAmount = s_erc20Balance;\n\t\t\tif (withdrawalAmount <= 0) {\n\t\t\t\trevert InvalidAmount();\n\t\t\t}\n\t\t\ts_erc20Balance = 0;\n\t\t\tTransferHelper.safeTransfer(\n\t\t\t\ts_erc20Token,\n\t\t\t\ti_creator,\n\t\t\t\twithdrawalAmount\n\t\t\t);\n\t\t\ts_isTSLActive = false; // Deactivate TSL when withdrawal is made\n\t\t}\n\t}\n\n\t/**\n\t * @notice Checks if upkeep is needed based on TSL conditions.\n\t * @dev Part of the Chainlink automation interface.\n\t * @return A tuple of three values: a boolean indicating if selling is needed, a boolean indicating if the threshold should be updated, and the new threshold value.\n\t */\n\tfunction checkUpkeepNeeded() external view returns (bool, bool, uint256) {\n\t\t// Implement logic to check if TSL conditions are met\n\t\tuint256 currentPrice = getTwapPrice();\n\t\tuint256 exactPrice = getExactPrice();\n\n\t\tbool triggerSell = false;\n\t\tbool updateThreshold = false;\n\t\tuint256 newThreshold = 0;\n\n\t\t// Calculate 10% price range bounds\n\t\tuint256 lowerBound = (currentPrice * 90) / 100;\n\t\tuint256 upperBound = (currentPrice * 110) / 100;\n\t\t//calculates the old all time high price based on the threshold\n\t\tuint256 oldCurrentPrice = (s_tslThreshold * 100) /\n\t\t\t(100 - s_trailAmount);\n\n\t\t//determines the price that is granularity% higher than the old stored price\n\t\tuint256 minPriceForUpdate = (oldCurrentPrice * (100 + s_granularity)) /\n\t\t\t100;\n\t\t//if new price is less than the current threshold then trigger TSL\n\t\tif (exactPrice >= lowerBound && exactPrice <= upperBound) {\n\t\t\tif (currentPrice < s_tslThreshold) {\n\t\t\t\t//trigger TSL\n\t\t\t\ttriggerSell = true;\n\t\t\t} else if (currentPrice > minPriceForUpdate) {\n\t\t\t\tupdateThreshold = true;\n\t\t\t\tnewThreshold = (currentPrice * (100 - s_trailAmount)) / 100;\n\t\t\t}\n\t\t}\n\t\treturn (triggerSell, updateThreshold, newThreshold);\n\t}\n\n\t/**\n\t * @notice Updates the trailing stop loss threshold.\n\t * @dev This function is private and should be called only by performUpkeep.\n\t * @param newThreshold The new threshold value to set.\n\t */\n\tfunction updateTSLThreshold(uint256 newThreshold) external onlyManager {\n\t\ts_tslThreshold = newThreshold;\n\t}\n\n\t/**\n\t * @notice Gets the latest price of the ERC20 token in stablecoins.\n\t * @dev Uses the Uniswap Oracle to get the latest price using TWAP (time-weighted average price) data for the past 5 minutes\n\t * @return The latest price of the ERC20 token in stablecoins.\n\t */\n\tfunction getTwapPrice() public view returns (uint256) {\n\t\tuint256 amountOut = s_uniswapOracle.estimateAmountOut(\n\t\t\ts_uniswapPool,\n\t\t\ts_erc20Token,\n\t\t\t1e18, // number of decimals for erc20 token\n\t\t\t300 // 5 minutes of price data (300 seconds)\n\t\t);\n\t\treturn amountOut;\n\t}\n\n\tfunction getExactPrice() public view returns (uint256) {\n\t\tuint256 amountOut = s_uniswapOracle.estimateAmountOut(\n\t\t\ts_uniswapPool,\n\t\t\ts_erc20Token,\n\t\t\t1e18, // number of decimals for erc20 token\n\t\t\t0 // 5 minutes of price data (300 seconds)\n\t\t);\n\t\treturn amountOut;\n\t}\n\n\t/**\n\t * @notice Swaps the user's ERC20 tokens for stablecoins on Uniswap.\n\t * @dev Currently public for testing, but intended to be private in deployment. Non-reentrant.\n\t * @param amount The amount of the ERC20 token to swap.\n\t */\n\tfunction swapOnUniswap(uint256 amount) public nonReentrant {\n\t\t//swap ERC20 tokens for stablecoin on uniswap\n\t\t//need to approve uniswap to spend ERC20 tokens\n\n\t\t//gets the most up to date price to calculate slippage\n\t\tuint256 currentPrice = getExactPrice();\n\t\tuint256 minAmountOut;\n\t\tif (slippageProtection) {\n\t\t\tminAmountOut = (amount * currentPrice * 995) / 1000; //99.5% of the current price\n\t\t} else {\n\t\t\tminAmountOut = 0;\n\t\t}\n\n\t\tIERC20(s_erc20Token).approve(address(s_uniswapRouter), amount);\n\n\t\ts_erc20Balance -= amount;\n\t\tISwapRouter.ExactInputSingleParams memory params = ISwapRouter\n\t\t\t.ExactInputSingleParams({\n\t\t\t\ttokenIn: s_erc20Token,\n\t\t\t\ttokenOut: s_stablecoin,\n\t\t\t\tfee: s_poolFee,\n\t\t\t\trecipient: address(this),\n\t\t\t\tdeadline: block.timestamp,\n\t\t\t\tamountIn: amount,\n\t\t\t\tamountOutMinimum: minAmountOut,\n\t\t\t\tsqrtPriceLimitX96: 0\n\t\t\t});\n\t\ts_uniswapRouter.exactInputSingle(params);\n\n\t\tuint256 amountRecieved = IERC20(s_stablecoin).balanceOf(address(this));\n\t\ts_stablecoinBalance += amountRecieved;\n\t}\n\n\t/**\n\t * @notice Activates slippage protection for token swaps.\n\t * @dev Can only be called by the contract owner.\n\t */\n\tfunction activateSlippageProtection() public onlyManager {\n\t\tslippageProtection = false;\n\t}\n\n\t// View functions for contract interaction and frontend integration\n\tfunction getERC20Balance() public view returns (uint256) {\n\t\treturn s_erc20Balance;\n\t}\n\n\tfunction getStablecoinBalance() public view returns (uint256) {\n\t\treturn s_stablecoinBalance;\n\t}\n\n\tfunction getTSLThreshold() public view returns (uint256) {\n\t\treturn s_tslThreshold;\n\t}\n\n\tfunction isTSLActive() public view returns (bool) {\n\t\treturn s_isTSLActive;\n\t}\n\n\t// View function to get ERC20 token address\n\tfunction getERC20TokenAddress() public view returns (address) {\n\t\treturn s_erc20Token;\n\t}\n\n\t// View function to get stablecoin address\n\tfunction getStablecoinAddress() public view returns (address) {\n\t\treturn s_stablecoin;\n\t}\n\n\t// View function to get Uniswap router address\n\tfunction getUniswapRouterAddress() public view returns (address) {\n\t\treturn address(s_uniswapRouter);\n\t}\n\n\tfunction getTrailAmount() public view returns (uint256) {\n\t\treturn s_trailAmount;\n\t}\n\n\tfunction getManager() public view returns (address) {\n\t\treturn i_manager;\n\t}\n\n\tfunction getCreator() public view returns (address) {\n\t\treturn i_creator;\n\t}\n\n\tfunction getGranularity() public view returns (uint256) {\n\t\treturn s_granularity;\n\t}\n\n\tfunction getUniswapPool() public view returns (address) {\n\t\treturn s_uniswapPool;\n\t}\n}\n"
    },
    "contracts/TrailMixManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport { AutomationCompatibleInterface } from \"@chainlink/contracts/src/v0.8/automation/interfaces/AutomationCompatibleInterface.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n// import {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nerror NotContractOwner(); // Error for when the caller is not the contract owner\n\nimport { TrailMix } from \"./TrailMix.sol\"; // Import TrailMix contract\nimport { ITrailMix } from \"./ITrailMix.sol\"; // Import ITrailMix interface\n\ncontract TrailMixManager is AutomationCompatibleInterface, ReentrancyGuard {\n\t//array storing all active strategies\n\taddress[] public activeStrategies;\n\t// mapping to store index of strategy in activeStrategies array\n\tmapping(address => uint256) private strategyIndex;\n\n\t//mapping for quick lookup for if a strategy is active\n\tmapping(address => bool) public isActiveStrategy;\n\n\t// Mapping from user address to array of deployed TrailMix contract addresses\n\tmapping(address => address[]) public userContracts;\n\n\t// Event to emit when a new TrailMix contract is deployed\n\tevent ContractDeployed(\n\t\taddress indexed creator,\n\t\taddress contractAddress,\n\t\tuint256 timestamp\n\t);\n\n\tevent FundsDeposited(\n\t\taddress indexed creator,\n\t\taddress indexed strategy,\n\t\tuint256 amount,\n\t\taddress token,\n\t\tuint256 timestamp\n\t);\n\tevent FundsWithdrawn(\n\t\taddress indexed creator,\n\t\taddress indexed strategy,\n\t\tuint256 amount,\n\t\taddress token,\n\t\tuint256 timestamp\n\t);\n\tevent ThresholdUpdated(\n\t\taddress indexed strategy,\n\t\tuint256 oldThreshold,\n\t\tuint256 newThreshold,\n\t\tuint256 timestamp\n\t);\n\tevent SwapExecuted(\n\t\taddress indexed strategy,\n\t\taddress indexed creator,\n\t\tuint256 amountIn,\n\t\tuint256 amountOut,\n\t\taddress tokenIn,\n\t\taddress tokenOut,\n\t\tuint256 timestamp\n\t);\n\n\t// Function to deploy a new TrailMix contract\n\tfunction deployTrailMix(\n\t\taddress _erc20Token,\n\t\taddress _stablecoin,\n\t\taddress _uniswapRouter,\n\t\taddress _uniswapPool,\n\t\taddress _uniswapOracle,\n\t\tuint256 _trailAmount,\n\t\tuint256 _granularity,\n\t\tuint24 _poolFee\n\t) public {\n\t\t// Deploy the TrailMix contract\n\t\tTrailMix newTrailMix = new TrailMix(\n\t\t\taddress(this), // The TrailMixManager contract address\n\t\t\tmsg.sender, // The user becomes the creator of the TrailMix contract\n\t\t\t_erc20Token,\n\t\t\t_stablecoin,\n\t\t\t_uniswapRouter,\n\t\t\t_uniswapPool,\n\t\t\t_uniswapOracle,\n\t\t\t_trailAmount,\n\t\t\t_granularity,\n\t\t\t_poolFee\n\t\t);\n\n\t\t// Store the contract address in the userContracts mapping\n\t\tuserContracts[msg.sender].push(address(newTrailMix));\n\t\tactiveStrategies.push(address(newTrailMix));\n\t\tisActiveStrategy[address(newTrailMix)] = true;\n\t\tstrategyIndex[address(newTrailMix)] = activeStrategies.length - 1;\n\n\t\t// Emit an event for the deployment\n\t\temit ContractDeployed(\n\t\t\tmsg.sender,\n\t\t\taddress(newTrailMix),\n\t\t\tblock.timestamp\n\t\t);\n\t}\n\n\t// IMPLEMENT DEPOSIT AND WITHDRAW FUNCTIONS\n\tfunction deposit(\n\t\taddress _strategy,\n\t\tuint256 _amount,\n\t\tuint256 _tslThreshold\n\t) public {\n\t\tif (ITrailMix(_strategy).getCreator() != msg.sender) {\n\t\t\trevert NotContractOwner();\n\t\t}\n\n\t\t// Get the ERC20 token address from the TrailMix contract\n\t\taddress erc20TokenAddress = ITrailMix(_strategy).getERC20TokenAddress();\n\t\t//transfer funds from user to the manager contract\n\t\tIERC20(erc20TokenAddress).transferFrom(\n\t\t\tmsg.sender,\n\t\t\taddress(this),\n\t\t\t_amount\n\t\t);\n\n\t\t// approve strategy to spend the funds and call deposit\n\t\tIERC20(erc20TokenAddress).approve(_strategy, _amount);\n\t\tITrailMix(_strategy).deposit(_amount, _tslThreshold);\n\n\t\t// Emit an event for the deposit\n\t\temit FundsDeposited(\n\t\t\tmsg.sender,\n\t\t\t_strategy,\n\t\t\t_amount,\n\t\t\tITrailMix(_strategy).getERC20TokenAddress(),\n\t\t\tblock.timestamp\n\t\t);\n\t}\n\n\tfunction withdraw(address _strategy) public nonReentrant {\n\t\t// Withdraw the user's funds from the TrailMix contract\n\t\tif (ITrailMix(_strategy).getCreator() != msg.sender) {\n\t\t\trevert NotContractOwner();\n\t\t}\n\t\tITrailMix(_strategy).withdraw();\n\t\tremoveStrategy(_strategy);\n\t}\n\n\t// Remove a strategy\n\tfunction removeStrategy(address strategy) private {\n\t\trequire(strategy != address(0), \"Invalid address\");\n\t\trequire(isActiveStrategy[strategy], \"Strategy not active\");\n\n\t\tisActiveStrategy[strategy] = false;\n\n\t\t// Move the last element into the place to delete\n\t\tuint256 index = strategyIndex[strategy];\n\t\taddress lastStrategy = activeStrategies[activeStrategies.length - 1];\n\t\tactiveStrategies[index] = lastStrategy;\n\t\tstrategyIndex[lastStrategy] = index;\n\t\tactiveStrategies.pop();\n\n\t\t// Clean up\n\t\tdelete strategyIndex[strategy];\n\t}\n\n\t/**\n\t * @notice Checks if upkeep is needed based on TSL conditions.COMPUTED OFF-CHAIN\n\t * @dev Part of the Chainlink automation interface.\n\t * @param 'checkData' Not used in this implementation.\n\t * @return upkeepNeeded Boolean flag indicating if upkeep is needed.\n\t * @return performData Encoded data on what action to perform during upkeep.\n\t */\n\tfunction checkUpkeep(\n\t\tbytes calldata /*checkData*/\n\t) external view returns (bool upkeepNeeded, bytes memory performData) {\n\t\tfor (uint256 i = 0; i < activeStrategies.length; i++) {\n\t\t\t(bool sell, bool update, uint256 newThreshold) = ITrailMix(\n\t\t\t\tactiveStrategies[i]\n\t\t\t).checkUpkeepNeeded();\n\n\t\t\tif (sell) {\n\t\t\t\t// Prioritize swap action if needed\n\t\t\t\tperformData = abi.encode(\n\t\t\t\t\tactiveStrategies[i],\n\t\t\t\t\tsell,\n\t\t\t\t\tupdate,\n\t\t\t\t\tnewThreshold\n\t\t\t\t);\n\t\t\t\treturn (true, performData);\n\t\t\t} else if (update) {\n\t\t\t\t// If no swap needed, check for threshold update\n\t\t\t\t// Note: This approach only encodes action for the first strategy needing an action.\n\t\t\t\t// If you want to encode actions for all strategies, you'd need to aggregate the data differently.\n\t\t\t\tperformData = abi.encode(\n\t\t\t\t\tactiveStrategies[i],\n\t\t\t\t\tsell,\n\t\t\t\t\tupdate,\n\t\t\t\t\tnewThreshold\n\t\t\t\t);\n\t\t\t\t// Don't return yet if you want to prioritize sells across all strategies\n\t\t\t}\n\t\t}\n\n\t\tupkeepNeeded = (performData.length > 0);\n\t\t// performData already set within the loop for the first action identified\n\t\treturn (upkeepNeeded, performData);\n\t}\n\n\t/**\n\t * @notice Performs the upkeep of updating the stop loss threshold or triggering a sell.\n\t * @dev Part of the Chainlink automation interface.\n\t * @param performData Encoded data indicating the actions to perform.\n\t */\n\tfunction performUpkeep(bytes calldata performData) external override {\n\t\t// Implement logic to perform TSL (e.g., swap to stablecoin) when conditions are met\n\t\t(\n\t\t\taddress strategy,\n\t\t\tbool sell,\n\t\t\tbool updateThreshold,\n\t\t\tuint256 newThreshold\n\t\t) = abi.decode(performData, (address, bool, bool, uint256));\n\t\tif (sell) {\n\t\t\t//call trigger function to sell on uniswap\n\t\t\tuint256 s_erc20Balance = ITrailMix(strategy).getERC20Balance();\n\t\t\tITrailMix(strategy).swapOnUniswap(s_erc20Balance);\n\t\t\t//deactivate TSL\n\t\t\tremoveStrategy(strategy);\n\n\t\t\t//emit swap event\n\t\t\temit SwapExecuted(\n\t\t\t\tstrategy,\n\t\t\t\tITrailMix(strategy).getCreator(),\n\t\t\t\ts_erc20Balance,\n\t\t\t\tITrailMix(strategy).getStablecoinBalance(),\n\t\t\t\tITrailMix(strategy).getERC20TokenAddress(),\n\t\t\t\tITrailMix(strategy).getStablecoinAddress(),\n\t\t\t\tblock.timestamp\n\t\t\t);\n\t\t} else if (updateThreshold) {\n\t\t\t//call updateThreshold function to update the threshold\n\t\t\tITrailMix(strategy).updateTSLThreshold(newThreshold);\n\t\t\t//emit event for threshold update\n\t\t\temit ThresholdUpdated(\n\t\t\t\tstrategy,\n\t\t\t\tITrailMix(strategy).getTSLThreshold(),\n\t\t\t\tnewThreshold,\n\t\t\t\tblock.timestamp\n\t\t\t);\n\t\t}\n\t}\n\n\t// Function to get all contracts deployed by a user\n\tfunction getUserContracts(\n\t\taddress user\n\t) public view returns (address[] memory) {\n\t\treturn userContracts[user];\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}