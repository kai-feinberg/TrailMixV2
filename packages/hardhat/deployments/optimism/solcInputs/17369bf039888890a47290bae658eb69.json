{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.6.0;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nlibrary TransferHelper {\n    /// @notice Transfers tokens from the targeted address to the given destination\n    /// @notice Errors with 'STF' if transfer fails\n    /// @param token The contract address of the token to be transferred\n    /// @param from The originating address from which the tokens will be transferred\n    /// @param to The destination address of the transfer\n    /// @param value The amount to be transferred\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) =\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\n    }\n\n    /// @notice Transfers tokens from msg.sender to a recipient\n    /// @dev Errors with ST if transfer fails\n    /// @param token The contract address of the token which will be transferred\n    /// @param to The recipient of the transfer\n    /// @param value The value of the transfer\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\n    }\n\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\n    /// @dev Errors with 'SA' if transfer fails\n    /// @param token The contract address of the token to be approved\n    /// @param to The target of the approval\n    /// @param value The amount of the given token the target will be allowed to spend\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\n    }\n\n    /// @notice Transfers ETH to the recipient address\n    /// @dev Fails with `STE`\n    /// @param to The destination of the transfer\n    /// @param value The value to be transferred\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'STE');\n    }\n}\n"
    },
    "contracts/IERC20withDecimals.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// FORK OF OPPENZEPPLIN IERC20 CONTRACT WITH THE ADDED DECIMALS FUNCTION\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20withDecimals {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\r\n     * caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\r\n     * allowance mechanism. `value` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n\r\n    function decimals() external view returns (uint8);\r\n     \r\n}"
    },
    "contracts/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.7.5;\r\npragma abicoder v2;\r\n\r\nimport \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\";\r\n\r\n/// @title Router token swapping functionality\r\n/// @notice Functions for swapping tokens via Uniswap V3\r\ninterface ISwapRouter is IUniswapV3SwapCallback {\r\n\tstruct ExactInputSingleParams {\r\n\t\taddress tokenIn;\r\n\t\taddress tokenOut;\r\n\t\tuint24 fee;\r\n\t\taddress recipient;\r\n\t\tuint256 amountIn;\r\n\t\tuint256 amountOutMinimum;\r\n\t\tuint160 sqrtPriceLimitX96;\r\n\t}\r\n\r\n\t/// @notice Swaps `amountIn` of one token for as much as possible of another token\r\n\t/// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,\r\n\t/// and swap the entire amount, enabling contracts to send tokens before calling this function.\r\n\t/// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\r\n\t/// @return amountOut The amount of the received token\r\n\tfunction exactInputSingle(\r\n\t\tExactInputSingleParams calldata params\r\n\t) external payable returns (uint256 amountOut);\r\n\r\n\tstruct ExactInputParams {\r\n\t\tbytes path;\r\n\t\taddress recipient;\r\n\t\tuint256 amountIn;\r\n\t\tuint256 amountOutMinimum;\r\n\t}\r\n\r\n\t/// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\r\n\t/// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,\r\n\t/// and swap the entire amount, enabling contracts to send tokens before calling this function.\r\n\t/// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\r\n\t/// @return amountOut The amount of the received token\r\n\tfunction exactInput(\r\n\t\tExactInputParams calldata params\r\n\t) external payable returns (uint256 amountOut);\r\n\r\n\tstruct ExactOutputSingleParams {\r\n\t\taddress tokenIn;\r\n\t\taddress tokenOut;\r\n\t\tuint24 fee;\r\n\t\taddress recipient;\r\n\t\tuint256 amountOut;\r\n\t\tuint256 amountInMaximum;\r\n\t\tuint160 sqrtPriceLimitX96;\r\n\t}\r\n\r\n\t/// @notice Swaps as little as possible of one token for `amountOut` of another token\r\n\t/// that may remain in the router after the swap.\r\n\t/// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\r\n\t/// @return amountIn The amount of the input token\r\n\tfunction exactOutputSingle(\r\n\t\tExactOutputSingleParams calldata params\r\n\t) external payable returns (uint256 amountIn);\r\n\r\n\tstruct ExactOutputParams {\r\n\t\tbytes path;\r\n\t\taddress recipient;\r\n\t\tuint256 amountOut;\r\n\t\tuint256 amountInMaximum;\r\n\t}\r\n\r\n\t/// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\r\n\t/// that may remain in the router after the swap.\r\n\t/// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\r\n\t/// @return amountIn The amount of the input token\r\n\tfunction exactOutput(\r\n\t\tExactOutputParams calldata params\r\n\t) external payable returns (uint256 amountIn);\r\n}\r\n"
    },
    "contracts/ITrailMix.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\ninterface ITrailMix {\r\n\t// Function signatures\r\n\tfunction deposit(uint256 amount, uint256 tslThreshold) external;\r\n\r\n\tfunction withdraw(address token) external;\r\n\r\n\tfunction checkUpkeepNeeded() external view returns (bool, bool, uint256);\r\n\r\n\tfunction updateTSLThreshold(uint256 newThreshold) external;\r\n\r\n\tfunction swapOnUniswap(uint256 amount) external;\r\n\r\n\tfunction getTwapPrice() external view returns (uint256);\r\n\r\n\tfunction getExactPrice() external view returns (uint256);\r\n\r\n\tfunction toggleSlippageProtection() external;\r\n\r\n\tfunction getERC20Balance() external view returns (uint256);\r\n\r\n\tfunction getStablecoinBalance() external view returns (uint256);\r\n\r\n\tfunction getTSLThreshold() external view returns (uint256);\r\n\r\n\tfunction isTSLActive() external view returns (bool);\r\n\r\n\tfunction getERC20TokenAddress() external view returns (address);\r\n\r\n\tfunction getStablecoinAddress() external view returns (address);\r\n\r\n\tfunction getUniswapRouterAddress() external view returns (address);\r\n\r\n\tfunction getTrailAmount() external view returns (uint256);\r\n\r\n\tfunction getManager() external view returns (address);\r\n\r\n\tfunction getCreator() external view returns (address);\r\n\r\n\tfunction getGranularity() external view returns (uint256);\r\n\r\n\tfunction getUniswapPool() external view returns (address);\r\n\t\r\n\tfunction getProfit() external view returns (int256);\r\n\r\n}\r\n"
    },
    "contracts/IUniswapOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\ninterface IUniswapOracle {\r\n    function estimateAmountOut(\r\n        address pool,\r\n        address tokenIn,\r\n        uint128 amountIn,\r\n        uint32 secondsAgo\r\n    ) external view returns (uint amountOut);\r\n}\r\n"
    },
    "contracts/TrailMix.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\npragma abicoder v2;\r\n\r\nimport \"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\";\r\nimport { ISwapRouter } from \"./ISwapRouter.sol\";\r\nimport { IERC20withDecimals } from \"./IERC20withDecimals.sol\";\r\n\r\n// import {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport { IUniswapOracle } from \"./IUniswapOracle.sol\";\r\n\r\nerror InvalidAmount(); // Error for when the deposit amount is not positive\r\nerror TransferFailed(); // Error for when the token transfer fails\r\nerror InvalidToken(); // Error for when the token address is invalid\r\nerror StrategyNotActive();\r\n\r\n//events are emitted in the manager contract\r\ncontract TrailMix is ReentrancyGuard {\r\n\taddress private immutable i_manager; //address of the manager contract\r\n\taddress private immutable i_creator; // address of the creator of the contract\r\n\r\n\taddress private s_erc20Token;\r\n\taddress private s_stablecoin;\r\n\r\n\tISwapRouter private s_uniswapRouter;\r\n\taddress public immutable s_uniswapPool;\r\n\tIUniswapOracle private s_uniswapOracle; // TWAP oracle for Uniswap V3\r\n\r\n\tuint256 private immutable s_trailAmount; // Amount to trail by as a %\r\n\tuint256 private s_tslThreshold; // User's TSL threshold\r\n\tuint256 private s_erc20Balance;\r\n\tuint256 private s_stablecoinBalance; // User's ERC20 token balance\r\n\tuint256 private s_granularity; //  % price increase to trigger an update\r\n\tbool private slippageProtection; // Indicates if slippage protection is enabled\r\n\tuint24 private s_poolFee;\r\n\r\n\t//USED FOR PROFIT TRACKING\r\n\tuint256 private s_weightedEntryPrice;\r\n\tuint256 private s_totalDeposited; // Total amount deposited in ERC20\r\n\tuint256 private s_exitPrice;\r\n\tuint8 private s_stablecoinDecimals; //number of decimals the stablecoin has\r\n\tuint8 private s_erc20TokenDecimals;\r\n\r\n\t//stores current state of contract\r\n\tenum ContractState {\r\n\t\tUninitialized,\r\n\t\tActive,\r\n\t\tClaimable,\r\n\t\tInactive\r\n\t}\r\n\tContractState private state;\r\n\r\n\tconstructor(\r\n\t\taddress _manager,\r\n\t\taddress _creator,\r\n\t\taddress _erc20Token,\r\n\t\taddress _stablecoin,\r\n\t\taddress _uniswapRouter,\r\n\t\taddress _uniswapPool,\r\n\t\taddress _uniswapOracle,\r\n\t\tuint256 _trailAmount,\r\n\t\tuint256 granularity,\r\n\t\tuint24 _poolFee\r\n\t) {\r\n\t\ti_manager = _manager;\r\n\t\ti_creator = _creator;\r\n\r\n\t\ts_erc20Token = _erc20Token;\r\n\t\ts_stablecoin = _stablecoin;\r\n\r\n\t\ts_uniswapRouter = ISwapRouter(_uniswapRouter);\r\n\t\ts_uniswapOracle = IUniswapOracle(_uniswapOracle);\r\n\t\ts_uniswapPool = _uniswapPool;\r\n\r\n\t\ts_trailAmount = _trailAmount;\r\n\t\tslippageProtection = true;\r\n\t\ts_granularity = granularity;\r\n\t\ts_poolFee = _poolFee;\r\n\t\tstate = ContractState.Uninitialized;\r\n\t\ts_stablecoinDecimals = IERC20withDecimals(_stablecoin).decimals();\r\n\t\ts_erc20TokenDecimals = IERC20withDecimals(_erc20Token).decimals();\r\n\t}\r\n\r\n\tmodifier onlyManager() {\r\n\t\trequire(msg.sender == i_manager, \"only callable by manager contract\");\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Deposits a specified amount of the ERC20 token into the contract.\r\n\t * @param amount The amount of the ERC20 token to deposit.\r\n\t * @param tslThreshold The initial trailing stop loss threshold as a percentage.\r\n\t */\r\n\tfunction deposit(\r\n\t\tuint256 amount,\r\n\t\tuint256 tslThreshold\r\n\t) external onlyManager {\r\n\t\tif (amount <= 0) {\r\n\t\t\trevert InvalidAmount();\r\n\t\t}\r\n\t\tif (\r\n\t\t\tstate == ContractState.Claimable || state == ContractState.Inactive\r\n\t\t) {\r\n\t\t\trevert StrategyNotActive();\r\n\t\t}\r\n\r\n\t\tbool transferSuccess = IERC20withDecimals(s_erc20Token).transferFrom(\r\n\t\t\ti_manager,\r\n\t\t\taddress(this),\r\n\t\t\tamount\r\n\t\t);\r\n\t\tif (!transferSuccess) {\r\n\t\t\trevert TransferFailed();\r\n\t\t}\r\n\r\n\t\ts_erc20Balance += amount;\r\n\r\n\t\tif (state == ContractState.Uninitialized) {\r\n\t\t\t// If TSL is not active, set the threshold and activate TSL\r\n\t\t\ts_tslThreshold = (tslThreshold * (100 - s_trailAmount)) / 100;\r\n\r\n\t\t\tstate = ContractState.Active;\r\n\t\t}\r\n\r\n\t\t//store price at time of deposit\r\n\t\tuint256 currentPrice = getExactPrice();\r\n\r\n\t\ts_weightedEntryPrice =\r\n\t\t\t(s_weightedEntryPrice * s_totalDeposited + currentPrice * amount) /\r\n\t\t\t(s_totalDeposited + amount);\r\n\t\ts_totalDeposited += amount;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Withdraws the user's funds from the contract.\r\n\t * @dev Allows withdrawal of either ERC20 tokens or stablecoins\r\n\t */\r\n\tfunction withdraw(address token) external onlyManager {\r\n\t\tuint256 withdrawalAmount;\r\n\r\n\t\tif (token == s_stablecoin) {\r\n\t\t\t// Logic to handle stablecoin withdrawal\r\n\t\t\twithdrawalAmount = s_stablecoinBalance;\r\n\t\t\tif (withdrawalAmount <= 0) {\r\n\t\t\t\trevert InvalidAmount();\r\n\t\t\t}\r\n\t\t\ts_stablecoinBalance = 0;\r\n\t\t\tTransferHelper.safeTransfer(\r\n\t\t\t\ts_stablecoin,\r\n\t\t\t\ti_creator, // sends funds to the contract creator\r\n\t\t\t\twithdrawalAmount\r\n\t\t\t);\r\n\t\t\t//deactiveate TSL\r\n\t\t\tstate = ContractState.Inactive;\r\n\t\t} else if (token == s_erc20Token) {\r\n\t\t\t// If TSL is active, user withdraws their ERC20 tokens\r\n\t\t\twithdrawalAmount = s_erc20Balance;\r\n\t\t\tif (withdrawalAmount <= 0) {\r\n\t\t\t\trevert InvalidAmount();\r\n\t\t\t}\r\n\t\t\ts_erc20Balance = 0;\r\n\t\t\tTransferHelper.safeTransfer(\r\n\t\t\t\ts_erc20Token,\r\n\t\t\t\ti_creator,\r\n\t\t\t\twithdrawalAmount\r\n\t\t\t);\r\n\t\t\t//deactivate tsl\r\n\t\t\tstate = ContractState.Inactive;\r\n\t\t} else {\r\n\t\t\trevert InvalidToken();\r\n\t\t}\r\n\r\n\t\t//set exit price at withdrawal if not already set\r\n\t\tif (s_exitPrice == 0) {\r\n\t\t\ts_exitPrice = getExactPrice();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Checks if upkeep is needed based on TSL conditions.\r\n\t * @return A tuple of three values: a boolean indicating if selling is needed, a boolean indicating if the threshold should be updated, and the new threshold value.\r\n\t */\r\n\tfunction checkUpkeepNeeded() external view returns (bool, bool, uint256) {\r\n\t\t// Implement logic to check if TSL conditions are met\r\n\t\tuint256 currentPrice = getTwapPrice();\r\n\t\tuint256 exactPrice = getExactPrice();\r\n\r\n\t\tbool triggerSell = false;\r\n\t\tbool updateThreshold = false;\r\n\t\tuint256 newThreshold = 0;\r\n\r\n\t\t// Calculate 10% price range bounds\r\n\t\tuint256 lowerBound = (currentPrice * 90) / 100;\r\n\t\tuint256 upperBound = (currentPrice * 110) / 100;\r\n\t\t//calculates the old all time high price based on the threshold\r\n\t\tuint256 oldCurrentPrice = (s_tslThreshold * 100) /\r\n\t\t\t(100 - s_trailAmount);\r\n\r\n\t\t//determines the price that is granularity% higher than the old stored price\r\n\t\tuint256 minPriceForUpdate = (oldCurrentPrice * (100 + s_granularity)) /\r\n\t\t\t100;\r\n\t\t//if new price is less than the current threshold then trigger TSL\r\n\t\tif (exactPrice >= lowerBound && exactPrice <= upperBound) {\r\n\t\t\tif (currentPrice < s_tslThreshold) {\r\n\t\t\t\t//trigger TSL\r\n\t\t\t\ttriggerSell = true;\r\n\t\t\t} else if (currentPrice > minPriceForUpdate) {\r\n\t\t\t\tupdateThreshold = true;\r\n\t\t\t\tnewThreshold = (currentPrice * (100 - s_trailAmount)) / 100;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn (triggerSell, updateThreshold, newThreshold);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Updates the trailing stop loss threshold.\r\n\t * @dev This function is private and should be called only by performUpkeep.\r\n\t * @param newThreshold The new threshold value to set.\r\n\t */\r\n\tfunction updateTSLThreshold(uint256 newThreshold) external onlyManager {\r\n\t\ts_tslThreshold = newThreshold;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Gets the latest price of the ERC20 token in stablecoins.\r\n\t * @dev Uses the Uniswap Oracle to get the latest price using TWAP (time-weighted average price) data for the past 5 minutes\r\n\t * @return The latest price of the ERC20 token in stablecoins.\r\n\t */\r\n\tfunction getTwapPrice() public view returns (uint256) {\r\n\t\tuint256 amountOut = s_uniswapOracle.estimateAmountOut(\r\n\t\t\ts_uniswapPool,\r\n\t\t\ts_erc20Token,\r\n\t\t\t1e18, // number of decimals for erc20 token\r\n\t\t\t300 // 5 minutes of price data (300 seconds)\r\n\t\t);\r\n\t\treturn amountOut;\r\n\t}\r\n\r\n\tfunction getExactPrice() public view returns (uint256) {\r\n\t\tuint256 amountOut = s_uniswapOracle.estimateAmountOut(\r\n\t\t\ts_uniswapPool,\r\n\t\t\ts_erc20Token,\r\n\t\t\t1e18, // number of decimals for erc20 token\r\n\t\t\t1\r\n\t\t);\r\n\t\treturn amountOut;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Swaps the user's ERC20 tokens for stablecoins on Uniswap.\r\n\t * @dev only callable by the manager contract. Non-reentrant.\r\n\t * @param amount The amount of the ERC20 token to swap.\r\n\t */\r\n\tfunction swapOnUniswap(uint256 amount) public nonReentrant {\r\n\t\t//swap ERC20 tokens for stablecoin on uniswap\r\n\t\t//need to approve uniswap to spend ERC20 tokens\r\n\r\n\t\t//gets the most up to date price to calculate slippage\r\n\t\tuint256 currentPrice = getExactPrice();\r\n\t\tuint256 minAmountOut;\r\n\r\n\t\tuint256 feeBps = s_poolFee; //take into account the pool fees\r\n\r\n\t\tif (slippageProtection) {\r\n\t\t\tminAmountOut =\r\n\t\t\t\t(amount * currentPrice * (feeBps + 500)) /\r\n\t\t\t\t(100000 * 1e18); //99.5% of the current price (including pool fee)\r\n\t\t} else {\r\n\t\t\tminAmountOut = 0;\r\n\t\t}\r\n\r\n\t\tIERC20withDecimals(s_erc20Token).approve(\r\n\t\t\taddress(s_uniswapRouter),\r\n\t\t\tamount\r\n\t\t);\r\n\r\n\t\ts_erc20Balance -= amount;\r\n\t\tISwapRouter.ExactInputSingleParams memory params = ISwapRouter\r\n\t\t\t.ExactInputSingleParams({\r\n\t\t\t\ttokenIn: s_erc20Token,\r\n\t\t\t\ttokenOut: s_stablecoin,\r\n\t\t\t\tfee: s_poolFee,\r\n\t\t\t\trecipient: address(this),\r\n\t\t\t\t// deadline: block.timestamp, NOT NEEDED FOR ROUTER ON BASE\r\n\t\t\t\tamountIn: amount,\r\n\t\t\t\tamountOutMinimum: minAmountOut,\r\n\t\t\t\tsqrtPriceLimitX96: 0\r\n\t\t\t});\r\n\t\ts_uniswapRouter.exactInputSingle(params);\r\n\r\n\t\tuint256 amountRecieved = IERC20withDecimals(s_stablecoin).balanceOf(\r\n\t\t\taddress(this)\r\n\t\t);\r\n\t\ts_stablecoinBalance += amountRecieved;\r\n\t\ts_exitPrice = currentPrice;\r\n\t\tstate = ContractState.Claimable;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Activates slippage protection for token swaps.\r\n\t * @dev Can only be called by the contract owner.\r\n\t */\r\n\tfunction toggleSlippageProtection() public onlyManager {\r\n\t\tslippageProtection = !slippageProtection;\r\n\t}\r\n\r\n\t// View functions for contract interaction and frontend integration\r\n\tfunction getERC20Balance() public view returns (uint256) {\r\n\t\treturn s_erc20Balance;\r\n\t}\r\n\r\n\tfunction getStablecoinBalance() public view returns (uint256) {\r\n\t\treturn s_stablecoinBalance;\r\n\t}\r\n\r\n\tfunction getTSLThreshold() public view returns (uint256) {\r\n\t\treturn s_tslThreshold;\r\n\t}\r\n\r\n\t// View function to get ERC20 token address\r\n\tfunction getERC20TokenAddress() public view returns (address) {\r\n\t\treturn s_erc20Token;\r\n\t}\r\n\r\n\t// View function to get stablecoin address\r\n\tfunction getStablecoinAddress() public view returns (address) {\r\n\t\treturn s_stablecoin;\r\n\t}\r\n\r\n\t// View function to get Uniswap router address\r\n\tfunction getUniswapRouterAddress() public view returns (address) {\r\n\t\treturn address(s_uniswapRouter);\r\n\t}\r\n\r\n\tfunction getTrailAmount() public view returns (uint256) {\r\n\t\treturn s_trailAmount;\r\n\t}\r\n\r\n\tfunction getManager() public view returns (address) {\r\n\t\treturn i_manager;\r\n\t}\r\n\r\n\tfunction getCreator() public view returns (address) {\r\n\t\treturn i_creator;\r\n\t}\r\n\r\n\tfunction getGranularity() public view returns (uint256) {\r\n\t\treturn s_granularity;\r\n\t}\r\n\r\n\tfunction getUniswapPool() public view returns (address) {\r\n\t\treturn s_uniswapPool;\r\n\t}\r\n\r\n\tfunction getWeightedEntryPrice() public view returns (uint256) {\r\n\t\treturn s_weightedEntryPrice;\r\n\t}\r\n\r\n\tfunction getExitPrice() public view returns (uint256) {\r\n\t\treturn s_exitPrice;\r\n\t}\r\n\r\n\tfunction getState() public view returns (string memory) {\r\n\t\tif (state == ContractState.Uninitialized) return \"Uninitialized\";\r\n\t\tif (state == ContractState.Active) return \"Active\";\r\n\t\tif (state == ContractState.Claimable) return \"Claimable\";\r\n\t\tif (state == ContractState.Inactive) return \"Inactive\";\r\n\t\treturn \"Unknown\"; // fallback in case of an unexpected state\r\n\t}\r\n\r\n\tfunction getProfit() public view returns (int256) {\r\n\t\tuint256 scalingFactor = 10 ** uint256(s_erc20TokenDecimals);\r\n\r\n\t\tif (state == ContractState.Active) {\r\n\t\t\tuint256 livePrice = getExactPrice();\r\n\t\t\tuint256 currentValue = (s_erc20Balance * livePrice) / scalingFactor;\r\n\t\t\tuint256 totalCost = (s_totalDeposited * s_weightedEntryPrice) /\r\n\t\t\t\tscalingFactor;\r\n\t\t\treturn int256(currentValue) - int256(totalCost);\r\n\t\t} else if (\r\n\t\t\tstate == ContractState.Claimable || state == ContractState.Inactive\r\n\t\t) {\r\n\t\t\tuint256 profit = (s_totalDeposited *\r\n\t\t\t\t(s_exitPrice - s_weightedEntryPrice)) / scalingFactor;\r\n\t\t\treturn int256(profit);\r\n\t\t} else {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    "contracts/TrailMixManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n// import {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\n\r\nerror NotContractOwner(); // Error for when the caller is not the contract owner\r\n\r\nimport { TrailMix } from \"./TrailMix.sol\"; // Import TrailMix contract\r\nimport { ITrailMix } from \"./ITrailMix.sol\"; // Import ITrailMix interface\r\n\r\ncontract TrailMixManager is ReentrancyGuard {\r\n\t//array storing all active strategies\r\n\taddress[] public activeStrategies;\r\n\t// mapping to store index of strategy in activeStrategies array\r\n\tmapping(address => uint256) private strategyIndex;\r\n\r\n\t//mapping for quick lookup for if a strategy is active\r\n\tmapping(address => bool) public isActiveStrategy;\r\n\r\n\t// Mapping from user address to array of deployed TrailMix contract addresses\r\n\tmapping(address => address[]) public userContracts;\r\n\r\n\taddress private gelatoExecutor; //only address authorized to call performUpkeep\r\n\r\n\taddress private managerDeployer; //address authorized to set gelato executor\r\n\r\n\tmodifier onlyAuthorized() {\r\n\t\trequire(\r\n\t\t\tmsg.sender == address(this) ||\r\n\t\t\t\tmsg.sender == address(gelatoExecutor),\r\n\t\t\t\"Not authorized\"\r\n\t\t);\r\n\t\t_;\r\n\t}\r\n\r\n\t// Event to emit when a new TrailMix contract is deployed\r\n\tevent ContractDeployed(\r\n\t\taddress indexed creator,\r\n\t\taddress indexed contractAddress,\r\n\t\taddress indexed token,\r\n\t\tuint256 trailAmount,\r\n\t\tuint256 timestamp\r\n\t);\r\n\r\n\tevent FundsDeposited(\r\n\t\taddress indexed creator,\r\n\t\taddress indexed strategy,\r\n\t\tuint256 depositPrice,\r\n\t\tuint256 amount,\r\n\t\taddress token,\r\n\t\tuint256 timestamp,\r\n\t\tuint256 trailAmount\r\n\t);\r\n\tevent FundsWithdrawn(\r\n\t\taddress indexed creator,\r\n\t\taddress indexed strategy,\r\n\t\tuint256 amount,\r\n\t\taddress token,\r\n\t\tuint256 timestamp,\r\n\t\tuint256 trailAmount\r\n\t);\r\n\tevent ThresholdUpdated(\r\n\t\taddress indexed strategy,\r\n\t\tuint256 oldThreshold,\r\n\t\tuint256 newThreshold,\r\n\t\tuint256 timestamp\r\n\t);\r\n\tevent SwapExecuted(\r\n\t\taddress indexed strategy,\r\n\t\taddress indexed creator,\r\n\t\tuint256 amountIn,\r\n\t\tuint256 amountOut,\r\n\t\taddress tokenIn,\r\n\t\taddress tokenOut,\r\n\t\tuint256 timestamp\r\n\t);\r\n\r\n\tconstructor() {\r\n\t\tmanagerDeployer = msg.sender;\r\n\t}\r\n\r\n\t// Function to deploy a new TrailMix contract\r\n\tfunction deployTrailMix(\r\n\t\taddress _erc20Token,\r\n\t\taddress _stablecoin,\r\n\t\taddress _uniswapRouter,\r\n\t\taddress _uniswapPool,\r\n\t\taddress _uniswapOracle,\r\n\t\tuint256 _trailAmount,\r\n\t\tuint256 _granularity,\r\n\t\tuint24 _poolFee\r\n\t) public {\r\n\t\t// Deploy the TrailMix contract\r\n\t\tTrailMix newTrailMix = new TrailMix(\r\n\t\t\taddress(this), // The TrailMixManager contract address\r\n\t\t\tmsg.sender, // The user becomes the creator of the TrailMix contract\r\n\t\t\t_erc20Token,\r\n\t\t\t_stablecoin,\r\n\t\t\t_uniswapRouter,\r\n\t\t\t_uniswapPool,\r\n\t\t\t_uniswapOracle,\r\n\t\t\t_trailAmount,\r\n\t\t\t_granularity,\r\n\t\t\t_poolFee\r\n\t\t);\r\n\r\n\t\t// Store the contract address in the userContracts mapping\r\n\t\tuserContracts[msg.sender].push(address(newTrailMix));\r\n\r\n\t\t// Emit an event for the deployment\r\n\t\temit ContractDeployed(\r\n\t\t\tmsg.sender,\r\n\t\t\taddress(newTrailMix),\r\n\t\t\t_erc20Token,\r\n\t\t\t_trailAmount,\r\n\t\t\tblock.timestamp\r\n\t\t);\r\n\t}\r\n\r\n\tfunction deposit(\r\n\t\taddress _strategy,\r\n\t\tuint256 _amount,\r\n\t\tuint256 _tslThreshold\r\n\t) public {\r\n\t\tif (ITrailMix(_strategy).getCreator() != msg.sender) {\r\n\t\t\trevert NotContractOwner();\r\n\t\t}\r\n\r\n\t\t// Get the ERC20 token address from the TrailMix contract\r\n\t\taddress erc20TokenAddress = ITrailMix(_strategy).getERC20TokenAddress();\r\n\t\t//transfer funds from user to the manager contract\r\n\t\tIERC20(erc20TokenAddress).transferFrom(\r\n\t\t\tmsg.sender,\r\n\t\t\taddress(this),\r\n\t\t\t_amount\r\n\t\t);\r\n\r\n\t\t// approve strategy to spend the funds and call deposit\r\n\t\tIERC20(erc20TokenAddress).approve(_strategy, _amount);\r\n\t\tITrailMix(_strategy).deposit(_amount, _tslThreshold);\r\n\r\n\t\t//if contract is not in the active array then add it to the active array\r\n\t\tif (!isActiveStrategy[address(_strategy)]) {\r\n\t\t\tactiveStrategies.push(address(_strategy));\r\n\t\t\tisActiveStrategy[address(_strategy)] = true;\r\n\t\t\tstrategyIndex[address(_strategy)] = activeStrategies.length - 1;\r\n\t\t}\r\n\r\n\t\t// Emit an event for the deposit\r\n\t\temit FundsDeposited(\r\n\t\t\tmsg.sender,\r\n\t\t\t_strategy,\r\n\t\t\tITrailMix(_strategy).getExactPrice(),\r\n\t\t\t_amount,\r\n\t\t\tITrailMix(_strategy).getERC20TokenAddress(),\r\n\t\t\tblock.timestamp,\r\n\t\t\tITrailMix(_strategy).getTrailAmount()\r\n\t\t);\r\n\t}\r\n\r\n\tfunction withdraw(address _strategy, address _token) public nonReentrant {\r\n\t\t// Withdraw the user's funds from the TrailMix contract\r\n\t\tif (ITrailMix(_strategy).getCreator() != msg.sender) {\r\n\t\t\trevert NotContractOwner();\r\n\t\t}\r\n\r\n\t\tuint256 amount;\r\n\t\t//fetch amount to be withdrawn\r\n\t\tif (_token == ITrailMix(_strategy).getERC20TokenAddress()) {\r\n\t\t\tamount = ITrailMix(_strategy).getERC20Balance();\r\n\t\t} else {\r\n\t\t\tamount = ITrailMix(_strategy).getStablecoinBalance();\r\n\t\t}\r\n\r\n\t\tITrailMix(_strategy).withdraw(_token);\r\n\r\n\t\tif (isActiveStrategy[_strategy]) {\r\n\t\t\tremoveStrategy(_strategy);\r\n\t\t}\r\n\r\n\t\temit FundsWithdrawn(\r\n\t\t\tmsg.sender,\r\n\t\t\t_strategy,\r\n\t\t\tamount,\r\n\t\t\t_token,\r\n\t\t\tblock.timestamp,\r\n\t\t\tITrailMix(_strategy).getTrailAmount()\r\n\t\t);\r\n\t}\r\n\r\n\tfunction toggleSlippageProtection(address _strategy) public {\r\n\t\tif (ITrailMix(_strategy).getCreator() != msg.sender) {\r\n\t\t\trevert NotContractOwner();\r\n\t\t}\r\n\t\tITrailMix(_strategy).toggleSlippageProtection();\r\n\t}\r\n\r\n\t// Remove a strategy\r\n\tfunction removeStrategy(address strategy) private {\r\n\t\trequire(strategy != address(0), \"Invalid address\");\r\n\r\n\t\tisActiveStrategy[strategy] = false;\r\n\r\n\t\t// Move the last element into the place to delete\r\n\t\tuint256 index = strategyIndex[strategy];\r\n\t\taddress lastStrategy = activeStrategies[activeStrategies.length - 1];\r\n\t\tactiveStrategies[index] = lastStrategy;\r\n\t\tstrategyIndex[lastStrategy] = index;\r\n\t\tactiveStrategies.pop();\r\n\r\n\t\t// Clean up\r\n\t\tdelete strategyIndex[strategy];\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Checks if upkeep is needed based on TSL conditions.COMPUTED OFF-CHAIN\r\n\t * @dev Part of the Gelato automation\r\n\t * @return canExec Boolean flag indicating if upkeep is needed.\r\n\t * @return execPayload Encoded data on what action to perform during upkeep.\r\n\t */\r\n\tfunction checker()\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (bool canExec, bytes memory execPayload)\r\n\t{\r\n\t\tbool updateNeeded = false;\r\n\t\tbytes memory updateData;\r\n\t\tfor (uint256 i = 0; i < activeStrategies.length; i++) {\r\n\t\t\t(bool sell, bool update, uint256 newThreshold) = ITrailMix(\r\n\t\t\t\tactiveStrategies[i]\r\n\t\t\t).checkUpkeepNeeded();\r\n\r\n\t\t\tif (sell) {\r\n\t\t\t\t// Prioritize swap action if needed\r\n\t\t\t\treturn (\r\n\t\t\t\t\ttrue,\r\n\t\t\t\t\tabi.encodeWithSelector(\r\n\t\t\t\t\t\tthis.performUpkeep.selector,\r\n\t\t\t\t\t\tactiveStrategies[i],\r\n\t\t\t\t\t\tsell,\r\n\t\t\t\t\t\tupdate,\r\n\t\t\t\t\t\tnewThreshold\r\n\t\t\t\t\t)\r\n\t\t\t\t);\r\n\t\t\t} else if (update) {\r\n\t\t\t\t// If no swap needed, check for threshold update\r\n\t\t\t\t// Note: This approach only encodes action for the first strategy needing an action.\r\n\t\t\t\tif (!updateNeeded) {\r\n\t\t\t\t\tupdateNeeded = true;\r\n\t\t\t\t\tupdateData = abi.encodeWithSelector(\r\n\t\t\t\t\t\tthis.performUpkeep.selector,\r\n\t\t\t\t\t\tactiveStrategies[i],\r\n\t\t\t\t\t\tsell,\r\n\t\t\t\t\t\tupdate,\r\n\t\t\t\t\t\tnewThreshold\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (updateNeeded) {\r\n\t\t\treturn (true, updateData);\r\n\t\t}\r\n\r\n\t\treturn (false, \"\");\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Performs the upkeep of updating the stop loss threshold or triggering a sell.\r\n\t * @dev Part of the gelato automation.\r\n\t */\r\n\tfunction performUpkeep(\r\n\t\taddress strategy,\r\n\t\tbool sell,\r\n\t\tbool updateThreshold,\r\n\t\tuint256 newThreshold\r\n\t) external onlyAuthorized {\r\n\t\t_performUpkeep(strategy, sell, updateThreshold, newThreshold);\r\n\t}\r\n\r\n\tfunction _performUpkeep(\r\n\t\taddress strategy,\r\n\t\tbool sell,\r\n\t\tbool updateThreshold,\r\n\t\tuint256 newThreshold\r\n\t) private {\r\n\t\t// Implement logic to perform TSL (e.g., swap to stablecoin) when conditions are met\r\n\r\n\t\tif (sell) {\r\n\t\t\t//call trigger function to sell on uniswap\r\n\t\t\tuint256 s_erc20Balance = ITrailMix(strategy).getERC20Balance();\r\n\t\t\tITrailMix(strategy).swapOnUniswap(s_erc20Balance);\r\n\r\n\t\t\t//deactivate TSL\r\n\t\t\tif (isActiveStrategy[strategy]) {\r\n\t\t\t\tremoveStrategy(strategy);\r\n\t\t\t}\r\n\r\n\t\t\t//emit swap event\r\n\t\t\temit SwapExecuted(\r\n\t\t\t\tstrategy,\r\n\t\t\t\tITrailMix(strategy).getCreator(),\r\n\t\t\t\ts_erc20Balance,\r\n\t\t\t\tITrailMix(strategy).getStablecoinBalance(),\r\n\t\t\t\tITrailMix(strategy).getERC20TokenAddress(),\r\n\t\t\t\tITrailMix(strategy).getStablecoinAddress(),\r\n\t\t\t\tblock.timestamp\r\n\t\t\t);\r\n\t\t} else if (updateThreshold) {\r\n\t\t\tuint256 oldThreshold = ITrailMix(strategy).getTSLThreshold();\r\n\r\n\t\t\t//call updateThreshold function to update the threshold\r\n\t\t\tITrailMix(strategy).updateTSLThreshold(newThreshold);\r\n\t\t\t//emit event for threshold update\r\n\t\t\temit ThresholdUpdated(\r\n\t\t\t\tstrategy,\r\n\t\t\t\toldThreshold,\r\n\t\t\t\tnewThreshold,\r\n\t\t\t\tblock.timestamp\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\t// Function to get all contracts deployed by a user\r\n\tfunction getUserContracts(\r\n\t\taddress user\r\n\t) public view returns (address[] memory) {\r\n\t\treturn userContracts[user];\r\n\t}\r\n\r\n\tfunction setGelatoExecutor(address _executor) public {\r\n\t\t// Logic to set the Gelato executor address\r\n\t\trequire(msg.sender == managerDeployer, \"Not authorized\");\r\n\t\tgelatoExecutor = _executor;\r\n\t}\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}